아래는 **지금 캡처 화면(삼성증권 POP “종합차트” 창 상단의 종목코드 입력칸)** 기준으로, Playwright로 **(1) 입력칸 selector를 “프레임/캔버스/동적UI”까지 커버하도록 찾는 전략**과 **(2) Enter 후 화면 저장 로직**을 “실전 설계” 형태로 정리한 것입니다. (DOM을 직접 못 보는 상황이라, **단계별로 실패 시 다음 단계로 내려가는 다중-폴백 설계**로 잡았습니다.)

---

## 0) 전제: 가장 먼저 “어디에서 렌더링되는 UI인가”를 판별

POP 화면이 웹 DOM이라면 selector로 안정적으로 잡힙니다.
하지만 일부 증권사 화면은 **iframe 안**에 있거나, 심지어 **canvas/웹컴포넌트(Shadow DOM)/가상 DOM** 형태로 구성되어 selector가 불안정할 수 있습니다.

따라서 설계는 **A(정석 DOM) → B(iframe) → C(shadow) → D(캔버스/좌표)** 순으로 폴백합니다.

---

## 1) 프레임(iframe) 포함: “정확한 frame 찾기” 전략

### 1-1. frame 후보를 자동 탐색

* `page.frames()`로 모든 frame을 순회하면서,

  * “종합차트”, “주식”, “한국전력” 같은 **화면에 확실히 존재하는 텍스트**
  * 혹은 `input`, `textbox` 개수
  * 등을 기준으로 “차트가 들어있는 frame”을 식별합니다.

**탐색 로직(설계)**

1. 모든 frame에 대해:

   * `frame.locator("text=종합차트").count()` 또는 `text=주식` 등을 체크
   * 동시에 `frame.locator("input").count()` / `frame.get_by_role("textbox").count()` 체크
2. 점수가 가장 높은 frame을 “차트 frame”으로 선택
3. 이후 모든 locator는 그 frame을 기준으로만 수행

> 왜?
> iframe 안에 있으면 `page.locator(...)`로는 절대 못 잡고, `frame.locator(...)`로만 잡힙니다.

---

## 2) “종목코드 입력칸” selector 찾기 전략 (가장 중요)

캡처 기준으로 입력칸은 상단 좌측 “주식” 탭 옆에 **6자리 코드(015760)**가 들어간 작은 입력창입니다.

### 2-1. 1차(정석): Role 기반 + 속성 기반

우선 아래 우선순위로 시도합니다.

1. `get_by_role("textbox")` (가능하면 가장 안정적)
2. CSS 속성 기반:

   * `input[maxlength="6"]`
   * `input[pattern*="0-9"]`
   * `input[type="text"]` 중 **폭이 좁고(코드창), 상단 헤더 영역**에 있는 것

> 팁: 입력칸이 “값(value)”로 이미 6자리 숫자를 갖고 있으면
> `input[value="015760"]` 같은 방식으로 *초기 부트스트랩*도 가능합니다(하지만 종목 바뀌면 value가 바뀌므로 최종 셀렉터로 쓰진 않음).

### 2-2. 2차(상대 위치): “종목명 텍스트(한국전력) 기준으로 역추적”

상단에 종목명 “한국전력”이 보이므로, 이 텍스트를 anchor로 삼아 **바로 왼쪽에 있는 input을 찾는** 방식이 매우 강합니다.

* anchor: `locator("text=한국전력")`
* 그 주변에서 “가장 가까운 input”을 찾기:

  * XPath/relative selector 사용 (예: `xpath=preceding::input[1]` 또는 container 기준 descendant 탐색)

이 방식은 UI가 약간 바뀌어도 “한국전력” 텍스트가 존재하는 한 따라갑니다.

### 2-3. 3차(버튼 기준): “돋보기/조회 버튼”을 anchor로 입력칸 찾기

입력칸 오른쪽에 돋보기 아이콘(조회/검색 버튼)이 있는 경우가 많습니다.

* `button` 또는 `a` 요소 중 `title`, `aria-label`, tooltip에 “조회/검색”이 들어간 요소를 찾고
* 그 **바로 왼쪽 형제 input**을 찾습니다.

### 2-4. 4차(Shadow DOM 대응): 웹컴포넌트라면

Playwright는 **open shadow root**는 기본적으로 상당 부분 잘 관통합니다.
그래도 안 잡히면:

* “상단 헤더 컨테이너”를 먼저 잡고(예: “종합차트” 헤더 라인)
* 그 안에서 `locator("input, [contenteditable=true]")`를 찾는 방식으로 좁힙니다.

### 2-5. 최후 폴백(캔버스/가상 입력): 좌표 클릭 + 키 입력

입력칸이 진짜 DOM input이 아니라 **canvas에 그려진 가짜 입력창**이면 selector가 안 잡힙니다. 이때는:

1. **(추천 폴백)** 템플릿 매칭(OpenCV)으로 돋보기 아이콘/코드창 배경 이미지의 위치를 찾아 클릭
2. `keyboard.type(종목코드)` + `keyboard.press("Enter")`

좌표 폴백은 “해상도/줌/레이아웃”에 민감하므로,

* 브라우저 사이즈 고정 (`viewport`)
* OS 디스플레이 배율 고정
* 페이지 줌 100%
  같이 “환경 고정”이 필수입니다.

---

## 3) Enter 후 “차트 갱신” 대기 전략

`networkidle`은 이런 금융 UI에서 종종 잘 안 맞습니다(웹소켓/주기 폴링 때문에).
그래서 **UI 상태 변화 기반 대기**로 설계합니다.

권장 대기 조건 (우선순위):

1. 상단 종목명 텍스트가 목표 종목명으로 변경됨 (가능하다면)
2. 상단 코드창 value가 목표 코드로 변경됨
3. 차트 영역의 특정 텍스트(예: 날짜/가격) 일부가 변화함
4. 최후: `wait_for_timeout(1500~3000ms)` + 재확인(리트라이)

> 실무 팁: “입력 → Enter” 후 곧바로 캡처하면 **이전 차트가 찍히는** 경우가 많아서,
> 반드시 “변화 감지”를 넣는 게 핵심입니다.

---

## 4) 화면 저장(스크린샷) 로직 설계

### 4-1. “전체 화면” vs “차트 창만”

* **전체 화면 저장**: `page.screenshot(full_page=True)`

  * 장점: 간단
  * 단점: 불필요 영역 포함, 해상도/스크롤 영향
* **차트 창만 저장(권장)**: “종합차트 팝업 컨테이너”를 locator로 잡고 `locator.screenshot()`

  * 장점: 항상 같은 구성, 결과물이 깔끔
  * 단점: 팝업 컨테이너 selector가 필요

### 4-2. 저장 파일명 규칙(재현성/정렬)

예:

* `screenshots/YYYYMMDD/{code}_{HHMMSS}.png`
* 실패 시 디버그:

  * `screenshots/_debug/{code}_fail.png`
  * `page.content()` 저장(가능하면)

### 4-3. 캡처 직전 안정화(필수 체크리스트)

* 차트 창이 화면에 완전히 보이도록:

  * `popup_locator.scroll_into_view_if_needed()`
  * 다른 팝업/툴팁 가리면 닫기(ESC)
* 로딩 스피너가 있으면 사라질 때까지 대기
* 애니메이션/전환이 있으면 짧게 대기(200~500ms)

---

## 5) 운영 설계(로그인/세션/실패 복구)

* 로그인 필요한 페이지면:

  * 최초 1회 수동 로그인 후 `storage_state` 저장
  * 이후 자동 실행은 `storage_state` 로딩해서 세션 재사용
* 실패 복구:

  * 입력칸 찾기 실패 → (프레임 재탐색) → (폴백 좌표) → 그래도 실패면 debug dump 남기고 종료
* 리트라이:

  * 종목 입력/Enter는 2~3회까지 재시도 가능(간헐적 포커스 미스 대비)

---

## 6) 추천 구현 흐름(“이 순서대로 만들면 바로 동작 확인 가능”)

1. **codegen** 또는 `page.pause()`로 수동 조작을 한 번 녹화/관찰
2. frame 후보를 찾는 “탐색 함수”부터 고정
3. 입력칸 locator를 1~3차 전략으로 먼저 성공시키기
4. Enter 후 대기 조건을 “값/텍스트 변화 감지”로 고정
5. 차트 팝업 컨테이너 locator를 잡고 `locator.screenshot()`로 결과물 고정
6. 마지막에 좌표 폴백은 옵션으로 추가

---

원하시면 다음 단계로, **(A) Playwright Python 기준 코드 스켈레톤(프레임 탐색 + 입력 locator 폴백 + 대기 + 팝업만 캡처)** 를 “바로 실행 가능한 형태”로 작성해 드릴게요.
(이때는 실제 POP 페이지에서 **frame URL/DOM 단서 1~2개**만 잡히면 selector를 거의 확정할 수 있습니다.)

